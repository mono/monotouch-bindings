<?xml version="1.0" encoding="utf-8"?>
<Type Name="Linea" FullName="LineaProSdk.Linea">
  <TypeSignature Language="C#" Value="public class Linea : MonoTouch.Foundation.NSObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Linea extends MonoTouch.Foundation.NSObject" />
  <AssemblyInfo>
    <AssemblyName>LineaProSdk</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>MonoTouch.Foundation.NSObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>MonoTouch.Foundation.Register("Linea", true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <para>Provides access to <see cref="T:LineaProSdk.Linea" /> functions. </para>
    </summary>
    <remarks>
      <para>Provides access to <see cref="T:LineaProSdk.Linea" /> functions. </para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Linea ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("init")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Linea (MonoTouch.Foundation.NSCoder coder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSCoder coder) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("initWithCoder:")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="coder" Type="MonoTouch.Foundation.NSCoder" />
      </Parameters>
      <Docs>
        <param name="coder">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Linea (MonoTouch.Foundation.NSObjectFlag t);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class MonoTouch.Foundation.NSObjectFlag t) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="t" Type="MonoTouch.Foundation.NSObjectFlag" />
      </Parameters>
      <Docs>
        <param name="t">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Linea (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDelegate">
      <MemberSignature Language="C#" Value="public virtual void AddDelegate (MonoTouch.Foundation.NSObject newDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddDelegate(class MonoTouch.Foundation.NSObject newDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("addDelegate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newDelegate" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="newDelegate">the delegate that will be notified of  events </param>
        <summary>
          <para>Allows unlimited delegates to be added to a single class instance. This is useful in the case of global class and every view can use addDelegate when the view is shown and removeDelegate when no longer needs to monitor events </para>
        </summary>
        <remarks>
          <para>Allows unlimited delegates to be added to a single class instance. This is useful in the case of global class and every view can use addDelegate when the view is shown and removeDelegate when no longer needs to monitor events </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeCodeGetInformation">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSDictionary BarcodeCodeGetInformation (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSDictionary BarcodeCodeGetInformation(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeCodeGetInformation:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeCodeGetParam">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeCodeGetParam (int setting, out ulong value, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeCodeGetParam(int32 setting, unsigned int64 value, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeCodeGetParam:value:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="setting" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="setting">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <param name="value">To be added.</param>
        <param name="error">To be added.</param>
        <summary>
          <para>Reads configuration parameters directly from the code barcode engine. Refer to the barcode engine documentation for supported parameters. <para>TRUE if operation was successful </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Reads configuration parameters directly from the code barcode engine. Refer to the barcode engine documentation for supported parameters. <para>TRUE if operation was successful </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeCodeSetParam">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeCodeSetParam (int setting, ulong value, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeCodeSetParam(int32 setting, unsigned int64 value, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeCodeSetParam:value:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="setting" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="setting">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <param name="value">To be added.</param>
        <param name="error">To be added.</param>
        <summary>
          <para>Sends configuration parameters directly to the code barcode engine. Use this function with EXTREME care, you can easily render your barcode engine useless. Refer to the barcode engine documentation for supported parameters. <para>TRUE if operation was successful </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sends configuration parameters directly to the code barcode engine. Use this function with EXTREME care, you can easily render your barcode engine useless. Refer to the barcode engine documentation for supported parameters. <para>TRUE if operation was successful </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeCodeUpdateFirmware">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeCodeUpdateFirmware (string name, MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeCodeUpdateFirmware(string name, class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeCodeUpdateFirmware:data:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">the exact name of the firmware file </param>
        <param name="data">firmware file data to load </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs firmware update on the Code 2D barcode engines. Barcode update can take very long time, it is best to call this function from a thread and update the user interface when firmwareUpdateProgress delegate is called <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs firmware update on the Code 2D barcode engines. Barcode update can take very long time, it is best to call this function from a thread and update the user interface when firmwareUpdateProgress delegate is called <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeEnableBarcode">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeEnableBarcode (int barcodeType, bool enabled, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeEnableBarcode(int32 barcodeType, bool enabled, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeEnableBarcode:enabled:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="barcodeType" Type="System.Int32" />
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="barcodeType">barcode type, one of the BAR_* constants with the exception of BAR_LAST. You can use BAR_ALL to enable or disable all barcode types at once </param>
        <param name="enabled">enables or disables reading of that barcode type </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Enables or disables reading of specific barcode type. This setting is stored into the flash memory and will persists. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Enables or disables reading of specific barcode type. This setting is stored into the flash memory and will persists. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeEnginePowerControl">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeEnginePowerControl (bool engineOn, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeEnginePowerControl(bool engineOn, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeEnginePowerControl:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="engineOn" Type="System.Boolean" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="engineOn">TRUE will keep the engine powered on until the function is called with FALSE. In case of FALSE,  will work the usual way - powers on the engine just before scan operation. </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Allows basic control over the power to the barcode engine. By default <see cref="T:LineaProSdk.Linea" /> manages barcode engine by turning it on when scan operation is needed, then turning off after 5 seconds of inactivity. There are situations, where barcode engine should stay on to give better user experience, namely when using 2D barcode engine, which takes 1.7 seconds to start. This function is ignored for 1D barcode engines.</para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Allows basic control over the power to the barcode engine. By default <see cref="T:LineaProSdk.Linea" /> manages barcode engine by turning it on when scan operation is needed, then turning off after 5 seconds of inactivity. There are situations, where barcode engine should stay on to give better user experience, namely when using 2D barcode engine, which takes 1.7 seconds to start. This function is ignored for 1D barcode engines.</para>
          <para>
            <linebreak />
Be cautious using this function, if you pass TRUE to engineOn, the barcode engine will not turn off unless <see cref="T:LineaProSdk.Linea" /> is disconnected, program closes connection or iPod/iPhone goes to sleep, so it can drain the battery.</para>
          <para>
            <linebreak />
This setting does not persist, it is valid for current session only. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeEnginePowerControl">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeEnginePowerControl (bool engineOn, int maxTimeMinutes, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeEnginePowerControl(bool engineOn, int32 maxTimeMinutes, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeEnginePowerControl:maxTimeMinutes:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="engineOn" Type="System.Boolean" />
        <Parameter Name="maxTimeMinutes" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="engineOn">TRUE will keep the engine powered on until the function is called with FALSE. In case of FALSE,  will work the usual way - powers on the engine just before scan operation. </param>
        <param name="maxTimeMinutes">the maximum idle time the engine will be kept on, in minutes. After that time elapses, the engine will be turned off to conserve power. Recommended value - 60 min. Setting the time is supported only on version 2.64 and later, on older firmware versions the time parameter is ignored. </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Allows basic control over the power to the barcode engine. By default <see cref="T:LineaProSdk.Linea" /> manages barcode engine by turning it on when scan operation is needed, then turning off after 5 seconds of inactivity. There are situations, where barcode engine should stay on to give better user experience, namely when using 2D barcode engine, which takes 1.7 seconds to start. This function is ignored for 1D barcode engines.</para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Allows basic control over the power to the barcode engine. By default <see cref="T:LineaProSdk.Linea" /> manages barcode engine by turning it on when scan operation is needed, then turning off after 5 seconds of inactivity. There are situations, where barcode engine should stay on to give better user experience, namely when using 2D barcode engine, which takes 1.7 seconds to start. This function is ignored for 1D barcode engines.</para>
          <para>
            <linebreak />
Be cautious using this function, if you pass TRUE to engineOn, the barcode engine will not turn off unless <see cref="T:LineaProSdk.Linea" /> is disconnected, program closes connection or iPod/iPhone goes to sleep, so it can drain the battery.</para>
          <para>
            <linebreak />
This setting does not persist, it is valid for current session only. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeEngineResetToDefaults">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeEngineResetToDefaults (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeEngineResetToDefaults(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeEngineResetToDefaults:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs factory reset of the barcode module. This function is taxing, slow and should not be called often, emergency use only. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs factory reset of the barcode module. This function is taxing, slow and should not be called often, emergency use only. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeGetScanButtonMode">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeGetScanButtonMode (out int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeGetScanButtonMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeGetScanButtonMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">returns scan button mode, one of the: BUTTON_DISABLED's button will become inactive BUTTON_ENABLED's button will triger barcode scan when pressed </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns the current scan button mode. See barcodeSetScanButtonMode for more detailed description. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns the current scan button mode. See barcodeSetScanButtonMode for more detailed description. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeGetScanMode">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeGetScanMode (out int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeGetScanMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeGetScanMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">returns scanning mode, one of the MODE_* constants </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns the current scan mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns the current scan mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeGetScanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeGetScanTimeout (out int timeout, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeGetScanTimeout(int32 timeout, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeGetScanTimeout:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">returns scan timeout in seconds </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns the current scan timeout. See barcodeSetScanTimeout for more detailed description. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns the current scan timeout. See barcodeSetScanTimeout for more detailed description. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeGetTypeMode">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeGetTypeMode (out int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeGetTypeMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeGetTypeMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">returns barcode type mode, one of the: BARCODE_TYPE_DEFAULTdefault barcode types, listed in BARCODES enumeration BARCODE_TYPE_EXTENDEDextended barcode types, listed in BARCODES_EX enumeration </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns the current barcode type mode. See barcodeSetTypeMode for more detailed description. This setting will not persists. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns the current barcode type mode. See barcodeSetTypeMode for more detailed description. This setting will not persists. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeIntermecSetInitData">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeIntermecSetInitData (MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeIntermecSetInitData(class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeIntermecSetInitData:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">barcode engine initialization data (consult barcode engine manual) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Allows for a custom initialization string to be sent to the Intermec barcode engine. The data is sent directly, if the barcode is currently powered on, and every time it gets initialized. The setting does not persists, so it is best this command is called upon new connection with <see cref="T:LineaProSdk.Linea" />. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Allows for a custom initialization string to be sent to the Intermec barcode engine. The data is sent directly, if the barcode is currently powered on, and every time it gets initialized. The setting does not persists, so it is best this command is called upon new connection with <see cref="T:LineaProSdk.Linea" />. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeIsBarcodeEnabled">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeIsBarcodeEnabled (int type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeIsBarcodeEnabled(int32 type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeIsBarcodeEnabled:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="type">barcode type, one of the BAR_* constants with the exception of BAR_ALL and BAR_LAST </param>
        <summary>
          <para>Returns if the the engine is set to read the barcode type or not. <para>TRUE if the barcode is enabled </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns if the the engine is set to read the barcode type or not. <para>TRUE if the barcode is enabled </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeIsBarcodeSupported">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeIsBarcodeSupported (int type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeIsBarcodeSupported(int32 type) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeIsBarcodeSupported:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="type">barcode type, one of the BAR_* constants with the exception of BAR_ALL and BAR_LAST </param>
        <summary>
          <para>Returns if the the engine can read the barcode type or not. <para>TRUE if the barcode is supported </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns if the the engine can read the barcode type or not. <para>TRUE if the barcode is supported </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeOpticonGetIdent">
      <MemberSignature Language="C#" Value="public virtual string BarcodeOpticonGetIdent (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string BarcodeOpticonGetIdent(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeOpticonGetIdent:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Reads barcode engine's identification <para>opticon engine ident string if function succeeded, nil otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Reads barcode engine's identification <para>opticon engine ident string if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeOpticonSetInitString">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeOpticonSetInitString (string data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeOpticonSetInitString(string data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeOpticonSetInitString:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">barcode engine initialization data (consult barcode engine manual) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Allows for a custom initialization string to be sent to the Opticon barcode engine. The string is sent directly, if the barcode is currently powered on, and every time it gets initialized. The setting does not persists, so it is best this command is called upon new connection with <see cref="T:LineaProSdk.Linea" />. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Allows for a custom initialization string to be sent to the Opticon barcode engine. The string is sent directly, if the barcode is currently powered on, and every time it gets initialized. The setting does not persists, so it is best this command is called upon new connection with <see cref="T:LineaProSdk.Linea" />. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeOpticonSetParams">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeOpticonSetParams (string data, bool saveToFlash, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeOpticonSetParams(string data, bool saveToFlash, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeOpticonSetParams:saveToFlash:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
        <Parameter Name="saveToFlash" Type="System.Boolean" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">command string </param>
        <param name="saveToFlash">if TRUE, command also saves the settings to flash. Saving setting is slower, so should be in ideal case executed only once and the program to remember it. The scanner's power usually gets cut when  goes to sleep - 5 seconds of idle time, so any non-stored to flash settings are lost, but if barcodeEnginePowerControl:TRUE is used on 2D engine, then even non-saved to flash settings will persist until device disconnects (iOS goes to sleep, physical disconnect) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sends configuration parameters directly to the opticon barcode engine. Use this function with EXTREME care, you can easily render your barcode engine useless. Refer to the barcode engine documentation on supported commands.</para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sends configuration parameters directly to the opticon barcode engine. Use this function with EXTREME care, you can easily render your barcode engine useless. Refer to the barcode engine documentation on supported commands.</para>
          <para>
            <linebreak />
The function encapsulates the data with the ESC and CR so you don't have to send them. It optionally sends Z2 after the command to ensure settings are stored in the flash.</para>
          <para>
            <linebreak />
You can send multiple parameters with a single call if you format them as follows:<list type="bullet"><item><description>commands that take 2 symbols can be sent without any delimiters, like: "C1C2C3"</description></item><item><description>commands that take 3 symbols should be prefixed by [, like: "C1[C2AC3" (in this case commands are C1, C2A and C3</description></item><item><description>commands that take 4 symbols should be prefixed by ], like: "C1C2]C3AB" (in this case commands are C1, C2 and C3AB datacommand string saveToFlashif TRUE, command also saves the settings to flash. Saving setting is slower, so should be in ideal case executed only once and the program to remember it. The scanner's power usually gets cut when Linea goes to sleep - 5 seconds of idle time, so any non-stored to flash settings are lost, but if barcodeEnginePowerControl:TRUE is used on 2D engine, then even non-saved to flash settings will persist until device disconnects (iOS goes to sleep, physical disconnect) errorpointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information TRUE if function succeeded, FALSE otherwise </description></item></list></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeOpticonUpdateFirmware">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeOpticonUpdateFirmware (MonoTouch.Foundation.NSData firmwareData, bool bootLoader, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeOpticonUpdateFirmware(class MonoTouch.Foundation.NSData firmwareData, bool bootLoader, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeOpticonUpdateFirmware:bootLoader:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="firmwareData" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="bootLoader" Type="System.Boolean" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="firmwareData">firmware file data to load </param>
        <param name="bootLoader">TRUE if you are going to update bootloader, FALSE if normal firmware </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs firmware update on the optiocon 2D barcode engines. Barcode update can take very long time, it is best to call this function from a thread and update the user interface when firmwareUpdateProgress delegate is called <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs firmware update on the optiocon 2D barcode engines. Barcode update can take very long time, it is best to call this function from a thread and update the user interface when firmwareUpdateProgress delegate is called <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeSetScanButtonMode">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeSetScanButtonMode (int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeSetScanButtonMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeSetScanButtonMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">button mode, one of the: BUTTON_DISABLED's button will become inactive BUTTON_ENABLED's button will triger barcode scan when pressed </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sets <see cref="T:LineaProSdk.Linea" />'s scan button mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sets <see cref="T:LineaProSdk.Linea" />'s scan button mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeSetScanMode">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeSetScanMode (int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeSetScanMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeSetScanMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">scanning mode, one of the MODE_* constants </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sets <see cref="T:LineaProSdk.Linea" />'s barcode engine scan mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sets <see cref="T:LineaProSdk.Linea" />'s barcode engine scan mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeSetScanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeSetScanTimeout (int timeout, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeSetScanTimeout(int32 timeout, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeSetScanTimeout:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">barcode engine timeout in seconds [1-60] or 0 to disable timeout. Default is 0 </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sets the scan timeout. This it the max time that the laser will be on in single scan mode, or the time without scanning that will force the laser off in multi scan mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sets the scan timeout. This it the max time that the laser will be on in single scan mode, or the time without scanning that will force the laser off in multi scan mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeSetTypeMode">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeSetTypeMode (int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeSetTypeMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeSetTypeMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">barcode type mode, one of the: BARCODE_TYPE_DEFAULT (default)default barcode types, listed in BARCODES enumeration BARCODE_TYPE_EXTENDEDextended barcode types, listed in BARCODES_EX enumeration </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sets barcode type mode. <see cref="T:LineaProSdk.Linea" /> can return barcode type from the default list (listed in BARCODES) or extended one (listed in BARCODES_EX). The extended one is superset to the default, so current programs will be mostly unaffected if they switch from default to extended (with the exception of barcodes like UPC-A and UPC-E, which will be returned as UPC in the default list, but proper types in the extended. This setting will not persists. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sets barcode type mode. <see cref="T:LineaProSdk.Linea" /> can return barcode type from the default list (listed in BARCODES) or extended one (listed in BARCODES_EX). The extended one is superset to the default, so current programs will be mostly unaffected if they switch from default to extended (with the exception of barcodes like UPC-A and UPC-E, which will be returned as UPC in the default list, but proper types in the extended. This setting will not persists. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeStartScan">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeStartScan (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeStartScan(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeStartScan:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Starts barcode engine. In single scan mode the laser will be on until barcode is successfully read, the timeout elapses (set via call to barcodeSetScanTimeout) or if barcodeStopScan is called. In multi scan mode the laser will stay on even if barcode is successfully read allowing series of barcodes to be scanned within a single read session. The scanning will stop if no barcode is scanned in the timeout interval (set via call to barcodeSetScanTimeout) or if barcodeStopScan is called. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Starts barcode engine. In single scan mode the laser will be on until barcode is successfully read, the timeout elapses (set via call to barcodeSetScanTimeout) or if barcodeStopScan is called. In multi scan mode the laser will stay on even if barcode is successfully read allowing series of barcodes to be scanned within a single read session. The scanning will stop if no barcode is scanned in the timeout interval (set via call to barcodeSetScanTimeout) or if barcodeStopScan is called. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeStopScan">
      <MemberSignature Language="C#" Value="public virtual bool BarcodeStopScan (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BarcodeStopScan(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeStopScan:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Stops ongoing scan started with barcodeStartScan <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Stops ongoing scan started with barcodeStartScan <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BarcodeType2Text">
      <MemberSignature Language="C#" Value="public virtual string BarcodeType2Text (int barcodeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string BarcodeType2Text(int32 barcodeType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("barcodeType2Text:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="barcodeType" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="barcodeType">barcode type returned from scanBarcode </param>
        <summary>
          <para>Helper function to return string name of barcode type <para>barcode type name </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Helper function to return string name of barcode type <para>barcode type name </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtConnect">
      <MemberSignature Language="C#" Value="public virtual bool BtConnect (string address, string pin, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtConnect(string address, string pin, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btConnect:pin:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.String" />
        <Parameter Name="pin" Type="System.String" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="address">bluetooth address returned from btDiscoverDevices/btDiscoverPrinters </param>
        <param name="pin">PIN code if needed, or nil to try unencrypted connection </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Tries to connect to remote device. Once connection is established, use bluetooth streams to read/write to the remote device. <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Tries to connect to remote device. Once connection is established, use bluetooth streams to read/write to the remote device. <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDisconnect">
      <MemberSignature Language="C#" Value="public virtual bool BtDisconnect (string address, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtDisconnect(string address, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDisconnect:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.String" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="address">bluetooth address returned from btDiscoverDevices/btDiscoverPrinters </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Disconnects from remote device. Currently, due to bluetooth module limitation disconnect actually performs module power off and on, so the remote device may still hold on connected state for a while <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Disconnects from remote device. Currently, due to bluetooth module limitation disconnect actually performs module power off and on, so the remote device may still hold on connected state for a while <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDiscoverDevices">
      <MemberSignature Language="C#" Value="public virtual string[] BtDiscoverDevices (int maxDevices, double maxTime, int codTypes, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] BtDiscoverDevices(int32 maxDevices, float64 maxTime, int32 codTypes, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDiscoverDevices:maxTime:codTypes:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxDevices" Type="System.Int32" />
        <Parameter Name="maxTime" Type="System.Double" />
        <Parameter Name="codTypes" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="maxDevices">the maximum results to return </param>
        <param name="maxTime">the max time to discover, in seconds. Actual time may vary. </param>
        <param name="codTypes">bluetooth Class Of Device to look for or 0 to search for all bluetooth devices </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs synchronous discovery of the nearby bluetooth devices. This function is not recommended to be called on the main thread, use btDiscoverDevicesInBackground instead. <para>this function cannot be called once connection to remote device was established </para><para>array of strings of bluetooth addresses if function succeeded, nil otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs synchronous discovery of the nearby bluetooth devices. This function is not recommended to be called on the main thread, use btDiscoverDevicesInBackground instead. <para>this function cannot be called once connection to remote device was established </para><para>array of strings of bluetooth addresses if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDiscoverDevicesInBackground">
      <MemberSignature Language="C#" Value="public virtual bool BtDiscoverDevicesInBackground (int maxDevices, double maxTime, int codTypes, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtDiscoverDevicesInBackground(int32 maxDevices, float64 maxTime, int32 codTypes, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDiscoverDevicesInBackground:maxTime:codTypes:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxDevices" Type="System.Int32" />
        <Parameter Name="maxTime" Type="System.Double" />
        <Parameter Name="codTypes" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="maxDevices">the maximum results to return </param>
        <param name="maxTime">the max time to discover, in seconds. Actual time may vary. </param>
        <param name="codTypes">bluetooth Class Of Device to look for or 0 to search for all bluetooth devices </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs background discovery of nearby bluetooth devices. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs background discovery of nearby bluetooth devices. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDiscoverPinpads">
      <MemberSignature Language="C#" Value="public virtual string[] BtDiscoverPinpads (int maxDevices, double maxTime, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] BtDiscoverPinpads(int32 maxDevices, float64 maxTime, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDiscoverPinpads:maxTime:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxDevices" Type="System.Int32" />
        <Parameter Name="maxTime" Type="System.Double" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="maxDevices">the maximum results to return </param>
        <param name="maxTime">the max time to discover, in seconds. Actual time may vary. </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs discovery of supported pinpads. These include MPED-400 and PPAD1. <para>this function cannot be called once connection to remote device was established </para><para>array of strings containing bluetooth device address and bluetooth device name, i.e. if 2 devices are found, the list will contain "address 1",@"name 1",@"address 2",@"name 2" if function succeeded, nil otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs discovery of supported pinpads. These include MPED-400 and PPAD1. <para>this function cannot be called once connection to remote device was established </para><para>array of strings containing bluetooth device address and bluetooth device name, i.e. if 2 devices are found, the list will contain "address 1",@"name 1",@"address 2",@"name 2" if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDiscoverPinpadsInBackground">
      <MemberSignature Language="C#" Value="public virtual bool BtDiscoverPinpadsInBackground (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtDiscoverPinpadsInBackground(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDiscoverPinpadsInBackground:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs background discovery of supported printers. These include MPED-400 and PPAD1. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs background discovery of supported printers. These include MPED-400 and PPAD1. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDiscoverPinpadsInBackground">
      <MemberSignature Language="C#" Value="public virtual bool BtDiscoverPinpadsInBackground (int maxDevices, double maxTime, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtDiscoverPinpadsInBackground(int32 maxDevices, float64 maxTime, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDiscoverPinpadsInBackground:maxTime:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxDevices" Type="System.Int32" />
        <Parameter Name="maxTime" Type="System.Double" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="maxDevices">the maximum results to return, default is 4 </param>
        <param name="maxTime">the max time to discover, in seconds. Actual time may vary. </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs background discovery of supported printers. These include MPED-400 and PPAD1. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs background discovery of supported printers. These include MPED-400 and PPAD1. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDiscoverPrinters">
      <MemberSignature Language="C#" Value="public virtual string[] BtDiscoverPrinters (int maxDevices, double maxTime, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] BtDiscoverPrinters(int32 maxDevices, float64 maxTime, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDiscoverPrinters:maxTime:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxDevices" Type="System.Int32" />
        <Parameter Name="maxTime" Type="System.Double" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="maxDevices">the maximum results to return </param>
        <param name="maxTime">the max time to discover, in seconds. Actual time may vary. </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs discovery of supported printers. These include PP-60, DPP-250, DPP-350, SM-112, DPP-450. <para>this function cannot be called once connection to remote device was established </para><para>array of strings containing bluetooth device address and bluetooth device name, i.e. if 2 devices are found, the list will contain "address 1",@"name 1",@"address 2",@"name 2" if function succeeded, nil otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs discovery of supported printers. These include PP-60, DPP-250, DPP-350, SM-112, DPP-450. <para>this function cannot be called once connection to remote device was established </para><para>array of strings containing bluetooth device address and bluetooth device name, i.e. if 2 devices are found, the list will contain "address 1",@"name 1",@"address 2",@"name 2" if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDiscoverPrintersInBackground">
      <MemberSignature Language="C#" Value="public virtual bool BtDiscoverPrintersInBackground (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtDiscoverPrintersInBackground(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDiscoverPrintersInBackground:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs background discovery of supported printers. These include PP-60, DPP-250, DPP-350, SM-112, DPP-450. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs background discovery of supported printers. These include PP-60, DPP-250, DPP-350, SM-112, DPP-450. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDiscoverPrintersInBackground">
      <MemberSignature Language="C#" Value="public virtual bool BtDiscoverPrintersInBackground (int maxDevices, double maxTime, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtDiscoverPrintersInBackground(int32 maxDevices, float64 maxTime, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDiscoverPrintersInBackground:maxTime:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxDevices" Type="System.Int32" />
        <Parameter Name="maxTime" Type="System.Double" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="maxDevices">the maximum results to return, default is 4 </param>
        <param name="maxTime">the max time to discover, in seconds. Actual time may vary. </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs background discovery of supported printers. These include PP-60, DPP-250, DPP-350, SM-112, DPP-450. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs background discovery of supported printers. These include PP-60, DPP-250, DPP-350, SM-112, DPP-450. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtDiscoverSupportedDevicesInBackground">
      <MemberSignature Language="C#" Value="public virtual bool BtDiscoverSupportedDevicesInBackground (int maxDevices, double maxTime, int filter, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtDiscoverSupportedDevicesInBackground(int32 maxDevices, float64 maxTime, int32 filter, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btDiscoverSupportedDevicesInBackground:maxTime:filter:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxDevices" Type="System.Int32" />
        <Parameter Name="maxTime" Type="System.Double" />
        <Parameter Name="filter" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="maxDevices">the maximum results to return </param>
        <param name="maxTime">the max time to discover, in seconds. Actual time may vary. </param>
        <param name="filter">filter of which devices to discover, a combination of one or more of BLUETOOT_FILTER_* constants or BLUETOOTH_FILTER_ALL to get all supported devices </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs background discovery of nearby supported bluetooth devices. Supported devices are the ones some of the sdks has built-in support for - printers and pinpads. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs background discovery of nearby supported bluetooth devices. Supported devices are the ones some of the sdks has built-in support for - printers and pinpads. The discovery status and devices found will be sent via delegate notifications <para>this function cannot be called once connection to remote device was established </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtEnableWriteCaching">
      <MemberSignature Language="C#" Value="public virtual bool BtEnableWriteCaching (bool enabled, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtEnableWriteCaching(bool enabled, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btEnableWriteCaching:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enabled">enable or disable write caching, by default it is disabled </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Enables or disables write caching on the bluetooth stream. When enabled the writes gets cached and send on bigger chunks, reducing substantially the time taken, if you are sending lot of data in small parts. Write caching has negative effect on the speed if your bluetooth communication is based on request/response format or packets, in this case every write operation will get delayed, resulting in very poor throughput. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Enables or disables write caching on the bluetooth stream. When enabled the writes gets cached and send on bigger chunks, reducing substantially the time taken, if you are sending lot of data in small parts. Write caching has negative effect on the speed if your bluetooth communication is based on request/response format or packets, in this case every write operation will get delayed, resulting in very poor throughput. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtGetDeviceName">
      <MemberSignature Language="C#" Value="public virtual string BtGetDeviceName (string address, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string BtGetDeviceName(string address, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btGetDeviceName:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.String" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="address">bluetooth address returned from btDiscoverDevices/btDiscoverPrinters </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Queries device name given the address, this function complements the btDiscoverDevices/btDiscoverPrinters and as such is not recommended, use btDiscoverDevicesInBackground instead. <para>this function cannot be called once connection to remote device was established </para><para>bluetooth device name if function succeeded, nil otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Queries device name given the address, this function complements the btDiscoverDevices/btDiscoverPrinters and as such is not recommended, use btDiscoverDevicesInBackground instead. <para>this function cannot be called once connection to remote device was established </para><para>bluetooth device name if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtGetEnabled">
      <MemberSignature Language="C#" Value="public virtual bool BtGetEnabled (out bool enabled, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtGetEnabled(bool enabled, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btGetEnabled:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enabled">returns TRUE if bluetooth module is enabled, FALSE otherwise </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns bluethooth module status. <para>When bluetooth module is enabled, access to the barcode engine is not possible! </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns bluethooth module status. <para>When bluetooth module is enabled, access to the barcode engine is not possible! </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtGetLocalName">
      <MemberSignature Language="C#" Value="public virtual string BtGetLocalName (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string BtGetLocalName(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btGetLocalName:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Retrieves local bluetooth name, this is the name that <see cref="T:LineaProSdk.Linea" /> will report to bluetooth discovery requests. <para>this function cannot be called once connection to remote device was established </para><para>bluetooth name if function succeeded, nil otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Retrieves local bluetooth name, this is the name that <see cref="T:LineaProSdk.Linea" /> will report to bluetooth discovery requests. <para>this function cannot be called once connection to remote device was established </para><para>bluetooth name if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtInputStream">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSInputStream BtInputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSInputStream BtInputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("btInputStream", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSInputStream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BtOutputStream">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSOutputStream BtOutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSOutputStream BtOutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("btOutputStream", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSOutputStream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BtRead">
      <MemberSignature Language="C#" Value="public int BtRead (ref byte[] data, double timeout, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BtRead(unsigned int8[] data, float64 timeout, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]&amp;" RefType="ref" />
        <Parameter Name="timeout" Type="System.Double" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <param name="timeout">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BtReadLine">
      <MemberSignature Language="C#" Value="public virtual string BtReadLine (double timeout, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string BtReadLine(float64 timeout, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btReadLine:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Double" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="timeout">maximim timeout in seconds to wait for data </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Tries to read string data, ending with CR/LF up to specifed timeout <para>You can use bluethooth streams instead </para><para>string with the line read (can be empty string too) if function succeeded, nil otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Tries to read string data, ending with CR/LF up to specifed timeout <para>You can use bluethooth streams instead </para><para>string with the line read (can be empty string too) if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtSetDataNotificationMaxTime">
      <MemberSignature Language="C#" Value="public virtual bool BtSetDataNotificationMaxTime (double maxTime, int maxLength, MonoTouch.Foundation.NSData sequenceData, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtSetDataNotificationMaxTime(float64 maxTime, int32 maxLength, class MonoTouch.Foundation.NSData sequenceData, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btSetDataNotificationMaxTime:maxLength:sequenceData:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxTime" Type="System.Double" />
        <Parameter Name="maxLength" Type="System.Int32" />
        <Parameter Name="sequenceData" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="maxTime">notification will be fired 'maxTime' seconds after the last byte arrives, passing 0 disables it. For example 0.1 means that 100ms after the last byte is received the notification will fire. </param>
        <param name="maxLength">notification will be fired after 'maxLength' data arrives, passing 0 disables it. </param>
        <param name="sequenceData">notification will be fired if the received data contains 'sequenceData', passing nil disables it. </param>
        <param name="error">To be added.</param>
        <summary>
          <para>Sets the conditions to fire the NSStreamEventHasBytesAvailable event on bluetooth streams. If all special conditions are disabled, then the notification will be fired the moment data arrives. You can have multiple notifications active at the same time, for example maxBytes and maxTime. </para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sets the conditions to fire the NSStreamEventHasBytesAvailable event on bluetooth streams. If all special conditions are disabled, then the notification will be fired the moment data arrives. You can have multiple notifications active at the same time, for example maxBytes and maxTime. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtSetEnabled">
      <MemberSignature Language="C#" Value="public virtual bool BtSetEnabled (bool enabled, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtSetEnabled(bool enabled, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btSetEnabled:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enabled">TRUE to enable the engine, FALSE to disable it </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Enables or disables bluetooth module. Disabling the bluetooth module is currently the way to break existing bluetooth connection. <para>When bluetooth module is enabled, access to the barcode engine is not possible! </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Enables or disables bluetooth module. Disabling the bluetooth module is currently the way to break existing bluetooth connection. <para>When bluetooth module is enabled, access to the barcode engine is not possible! </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BtWrite">
      <MemberSignature Language="C#" Value="public bool BtWrite (byte[] data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool BtWrite(unsigned int8[] data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BtWrite">
      <MemberSignature Language="C#" Value="public virtual bool BtWrite (string data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BtWrite(string data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("btWrite:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">data string to write </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sends data to the connected remote device. <para>You can use bluethooth streams instead </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sends data to the connected remote device. <para>You can use bluethooth streams instead </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClassHandle">
      <MemberSignature Language="C#" Value="public override IntPtr ClassHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ClassHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public virtual void Connect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Connect() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("connect")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Tries to connect to <see cref="T:LineaProSdk.Linea" /> in the background, connection status notifications will be passed through the delegate. Once connect is called, it will automatically try to reconnect until disconnect is called. Note that "connect" call works in background and will notify the caller of connection success via connectionState delegate. Do not assume the library has fully connected to the device after this call, but wait for the notification. </para>
        </summary>
        <remarks>
          <para>Tries to connect to <see cref="T:LineaProSdk.Linea" /> in the background, connection status notifications will be passed through the delegate. Once connect is called, it will automatically try to reconnect until disconnect is called. Note that "connect" call works in background and will notify the caller of connection success via connectionState delegate. Do not assume the library has fully connected to the device after this call, but wait for the notification. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connstate">
      <MemberSignature Language="C#" Value="public virtual int Connstate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Connstate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("connstate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Returns current connection state </para>
        </summary>
        <value>To be added.</value>
        <remarks>
          <para>Returns current connection state </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptoAuthenticateDevice">
      <MemberSignature Language="C#" Value="public virtual bool CryptoAuthenticateDevice (MonoTouch.Foundation.NSData key, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CryptoAuthenticateDevice(class MonoTouch.Foundation.NSData key, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cryptoAuthenticateDevice:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">32 bytes AES256 key </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>
            <linebreak />
Generates random data, uses the key to encrypt it, then encrypts the same data with the stored authentication key inside <see cref="T:LineaProSdk.Linea" /> and returns true if both data matches.<para>Check out the cryptoRawAuthenticateDevice function, if you want to not use the key inside the mobile device.</para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
            <linebreak />
Generates random data, uses the key to encrypt it, then encrypts the same data with the stored authentication key inside <see cref="T:LineaProSdk.Linea" /> and returns true if both data matches.<para>Check out the cryptoRawAuthenticateDevice function, if you want to not use the key inside the mobile device.</para></para>
          <para>
            <linebreak />
The idea: if a program wants to work with specific <see cref="T:LineaProSdk.Linea" /> device, it sets AES256 authentication key once, then on every connect the program uses cryptoAuthenticateDevice with that key. If <see cref="T:LineaProSdk.Linea" /> contains no key, or the key is different, the function will return FALSE. This does not block <see cref="T:LineaProSdk.Linea" /> from operation, what action will be taken if devices mismatch depends on the program. <para>TRUE if if <see cref="T:LineaProSdk.Linea" /> contains the same authentication key, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptoAuthenticateHost">
      <MemberSignature Language="C#" Value="public virtual bool CryptoAuthenticateHost (MonoTouch.Foundation.NSData key, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CryptoAuthenticateHost(class MonoTouch.Foundation.NSData key, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cryptoAuthenticateHost:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">32 bytes AES256 key </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>
Generates random data, uses the key to encrypt it, then sends to <see cref="T:LineaProSdk.Linea" /> to verify against it's internal authentication key. If both keys match, return value is TRUE. This function is used so that <see cref="T:LineaProSdk.Linea" /> knows a "real" device is currently connected, before allowing some functionality. Currently firmware update is protected by this function, once authentication key is set, you have to use it or cryptoRawAuthenticateHost before you attempt firmware update, or it will error out. <para>Check out the cryptoRawAuthenticateHost function, if you want to not use the key inside the mobile device.</para><para>TRUE if <see cref="T:LineaProSdk.Linea" /> contains the same authentication key, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
Generates random data, uses the key to encrypt it, then sends to <see cref="T:LineaProSdk.Linea" /> to verify against it's internal authentication key. If both keys match, return value is TRUE. This function is used so that <see cref="T:LineaProSdk.Linea" /> knows a "real" device is currently connected, before allowing some functionality. Currently firmware update is protected by this function, once authentication key is set, you have to use it or cryptoRawAuthenticateHost before you attempt firmware update, or it will error out. <para>Check out the cryptoRawAuthenticateHost function, if you want to not use the key inside the mobile device.</para><para>TRUE if <see cref="T:LineaProSdk.Linea" /> contains the same authentication key, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptoGetKeyVersion">
      <MemberSignature Language="C#" Value="public virtual bool CryptoGetKeyVersion (int keyID, uint keyVersion, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CryptoGetKeyVersion(int32 keyID, unsigned int32 keyVersion, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cryptoGetKeyVersion:keyVersion:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyID" Type="System.Int32" />
        <Parameter Name="keyVersion" Type="System.UInt32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyID">returns key version or 0 if the key is not present (key versions are available in firmware 2.43 or later) </param>
        <param name="keyVersion">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <param name="error">To be added.</param>
        <summary>
          <para>Returns key version. Valid key ID:<list type="bullet"><item><description>KEY_AUTHENTICATION - if set, you can use authentication functions - cryptoRawAuthenticateDevice or cryptoAuthenticateDevice. Firmware updates will require authentication too</description></item><item><description>KEY_ENCRYPTION - if set, magnetic card data will come encrypted via magneticCardEncryptedData or magneticCardEncryptedRawData keyVersionreturns key version or 0 if the key is not present (key versions are available in firmware 2.43 or later) errorpointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information TRUE if function succeeded, FALSE otherwise </description></item></list></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns key version. Valid key ID:<list type="bullet"><item><description>KEY_AUTHENTICATION - if set, you can use authentication functions - cryptoRawAuthenticateDevice or cryptoAuthenticateDevice. Firmware updates will require authentication too</description></item><item><description>KEY_ENCRYPTION - if set, magnetic card data will come encrypted via magneticCardEncryptedData or magneticCardEncryptedRawData keyVersionreturns key version or 0 if the key is not present (key versions are available in firmware 2.43 or later) errorpointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information TRUE if function succeeded, FALSE otherwise </description></item></list></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptoRawAuthenticateDevice">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData CryptoRawAuthenticateDevice (MonoTouch.Foundation.NSData randomData, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData CryptoRawAuthenticateDevice(class MonoTouch.Foundation.NSData randomData, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cryptoRawAuthenticateDevice:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="randomData" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="randomData">16 bytes block of data (presumably random bytes) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>
            <linebreak />
Encrypts a 16 bytes block of random data with the stored authentication key and returns the result.<para>RAW crypto functions are harder to use and require more code, but are created to allow no secret keys to reside on the device, but all the operations can be execuded with data, sent from a secure server. See cryptoAuthenticateDevice if you plan to use the key in the mobile device.</para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
            <linebreak />
Encrypts a 16 bytes block of random data with the stored authentication key and returns the result.<para>RAW crypto functions are harder to use and require more code, but are created to allow no secret keys to reside on the device, but all the operations can be execuded with data, sent from a secure server. See cryptoAuthenticateDevice if you plan to use the key in the mobile device.</para></para>
          <para>
            <linebreak />
The idea: if a program wants to work with specific <see cref="T:LineaProSdk.Linea" /> device, it sets AES256 authentication key once, then on every connect the program generates random 16 byte block of data, encrypts it internally with the said key, then encrypts it with linea too and compares the result. If that <see cref="T:LineaProSdk.Linea" /> contains no key, or the key is different, the resulting data will totally differ from the one generated. This does not block <see cref="T:LineaProSdk.Linea" /> from operation, what action will be taken if devices mismatch depends on the program. <para>random data, encrypted with the <see cref="T:LineaProSdk.Linea" /> authentication key if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptoRawAuthenticateHost">
      <MemberSignature Language="C#" Value="public virtual bool CryptoRawAuthenticateHost (MonoTouch.Foundation.NSData encryptedRandomData, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CryptoRawAuthenticateHost(class MonoTouch.Foundation.NSData encryptedRandomData, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cryptoRawAuthenticateHost:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encryptedRandomData" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="encryptedRandomData">16 bytes block of encrypted data </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>
            <linebreak />
Tries to decrypt random data, generated from cryptoRawGenerateRandomData with the stored internal authentication key and returns the result. This function is used so that <see cref="T:LineaProSdk.Linea" /> knows a "real" device is currently connected, before allowing some functionality. Currently firmware update is protected by this function, once authentication key is set, you have to use it or cryptoAuthenticateHost before you attempt firmware update, or it will error out.<para>RAW crypto functions are harder to use and require more code, but are created to allow no secret keys to reside on the device, but all the operations can be execuded with data, sent from a secure server. See cryptoAuthenticateHost if you plan to use the key in the mobile device.</para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
            <linebreak />
Tries to decrypt random data, generated from cryptoRawGenerateRandomData with the stored internal authentication key and returns the result. This function is used so that <see cref="T:LineaProSdk.Linea" /> knows a "real" device is currently connected, before allowing some functionality. Currently firmware update is protected by this function, once authentication key is set, you have to use it or cryptoAuthenticateHost before you attempt firmware update, or it will error out.<para>RAW crypto functions are harder to use and require more code, but are created to allow no secret keys to reside on the device, but all the operations can be execuded with data, sent from a secure server. See cryptoAuthenticateHost if you plan to use the key in the mobile device.</para></para>
          <para>
            <linebreak />
The idea (considering the iOS device does not have the keys inside, but depends on server):<list type="bullet"><item><description>(iOS program) generates random data using cryptoRawGenerateRandomData and sends to the server</description></item><item><description>(Server) encrypts the random data with the same AES256 key that is in the Linea and sends back to the iOS program</description></item><item><description>(iOS program) uses cryptoRawAuthenticateHost to authenticate with the data, an exception will be generated if authentication fails. encryptedRandomData16 bytes block of encrypted data errorpointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information TRUE if function succeeded, FALSE otherwise </description></item></list></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptoRawGenerateRandomData">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData CryptoRawGenerateRandomData (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData CryptoRawGenerateRandomData(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cryptoRawGenerateRandomData:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Generates 16 byte block of random numbers, required for some of the other crypto functions. <para>16 bytes of random numbers if function succeeded, nil otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Generates 16 byte block of random numbers, required for some of the other crypto functions. <para>16 bytes of random numbers if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptoRawSetKey">
      <MemberSignature Language="C#" Value="public virtual bool CryptoRawSetKey (int keyID, MonoTouch.Foundation.NSData encryptedData, uint keyVersion, uint keyFlags, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CryptoRawSetKey(int32 keyID, class MonoTouch.Foundation.NSData encryptedData, unsigned int32 keyVersion, unsigned int32 keyFlags, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cryptoRawSetKey:encryptedData:keyVersion:keyFlags:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyID" Type="System.Int32" />
        <Parameter Name="encryptedData" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="keyVersion" Type="System.UInt32" />
        <Parameter Name="keyFlags" Type="System.UInt32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyID">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <param name="encryptedData">To be added.</param>
        <param name="keyVersion">To be added.</param>
        <param name="keyFlags">To be added.</param>
        <param name="error">To be added.</param>
        <summary>
          <para>
            <linebreak />
Used to store AES256 keys into <see cref="T:LineaProSdk.Linea" /> internal memory. Valid keys that can be set:<list type="bullet"><item><description>KEY_AUTHENTICATION - if set, you can use authentication functions - cryptoRawAuthenticateDevice or cryptoAuthenticateDevice. Firmware updates will require authentication too</description></item><item><description>KEY_ENCRYPTION - if set, magnetic card data will come encrypted via magneticCardEncryptedData or magneticCardEncryptedRawData</description></item></list><para>RAW crypto functions are harder to use and require more code, but are created to allow no secret keys to reside on the device, but all the operations can be execuded with data, sent from a secure server. See cryptoSetKey if you plan to use the key in the mobile device.</para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
            <linebreak />
Used to store AES256 keys into <see cref="T:LineaProSdk.Linea" /> internal memory. Valid keys that can be set:<list type="bullet"><item><description>KEY_AUTHENTICATION - if set, you can use authentication functions - cryptoRawAuthenticateDevice or cryptoAuthenticateDevice. Firmware updates will require authentication too</description></item><item><description>KEY_ENCRYPTION - if set, magnetic card data will come encrypted via magneticCardEncryptedData or magneticCardEncryptedRawData</description></item></list><para>RAW crypto functions are harder to use and require more code, but are created to allow no secret keys to reside on the device, but all the operations can be execuded with data, sent from a secure server. See cryptoSetKey if you plan to use the key in the mobile device.</para></para>
          <para>
            <linebreak />
Generally the key loading process, using "Raw" commands, a program on the iOS device and a server which holds the keys will look similar to:</para>
          <para>
            <list type="bullet">
              <item>
                <description>(iOS program) calls cryptoRawGenerateRandomData to get 16 bytes block of random data and send these to the server</description>
              </item>
              <item>
                <description>(Server) creates byte array of 48 bytes consisting of: [RANDOM DATA: 16 bytes][KEY DATA: 32 bytes]</description>
              </item>
              <item>
                <description>(Server) if there is current encryption key set on the Linea (if you want to change existing key) the server encrypts the 48 bytes block with the OLD key</description>
              </item>
              <item>
                <description>(Server) sends the result data back to the program</description>
              </item>
              <item>
                <description>(iOS program) calls cryptoRawSetKey with KEY_ENCRYPTION and the data it received from the server</description>
              </item>
              <item>
                <description>(Linea) tries to decrypt the key data if there was already key present, then extracts the key, verifies the random data and if everything is okay, sets the key keyIDthe key type to set - KEY_AUTHENTICATION or KEY_ENCRYPTION encryptedData- 48 bytes that consists of 16 bytes random numbers received via call to cryptoRawGenerateRandomData and 32 byte AES256 key. If there has been previous key of the same type, then all 48 bytes should be encrypted with it. keyVersion- the version of the key. On firmware versions less than 2.43 this parameter is ignored and key version is considered to be 0x00000000. Key version is useful for the program to determine what key is inside the head. keyFlags- optional key flags, supported on ver 2.58 and onward</description>
              </item>
              <item>
                <description>KEY_AUTHENTICATION: BIT 1If set to 1, scanning barcodes, reading magnetic card and using the bluetooth module are locked and have to be unlocked with cryptoAuthenticateHost/cryptoRawAuthenticateHost upon every reinsert of the device </description>
              </item>
              <item>
                <description>KEY_ENCRYPTION: No flags are supported errorpointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information TRUE if function succeeded, FALSE otherwise </description>
              </item>
            </list>
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptoSetKey">
      <MemberSignature Language="C#" Value="public virtual bool CryptoSetKey (int keyID, MonoTouch.Foundation.NSData key, MonoTouch.Foundation.NSData oldKey, uint keyVersion, uint keyFlags, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CryptoSetKey(int32 keyID, class MonoTouch.Foundation.NSData key, class MonoTouch.Foundation.NSData oldKey, unsigned int32 keyVersion, unsigned int32 keyFlags, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("cryptoSetKey:key:oldKey:keyVersion:keyFlags:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyID" Type="System.Int32" />
        <Parameter Name="key" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="oldKey" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="keyVersion" Type="System.UInt32" />
        <Parameter Name="keyFlags" Type="System.UInt32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyID">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <param name="key">To be added.</param>
        <param name="oldKey">To be added.</param>
        <param name="keyVersion">To be added.</param>
        <param name="keyFlags">To be added.</param>
        <param name="error">To be added.</param>
        <summary>
          <para>Used to store AES256 keys into <see cref="T:LineaProSdk.Linea" /> internal memory. Valid keys that can be set:<list type="bullet"><item><description>KEY_AUTHENTICATION - if set, you can use authentication functions - cryptoRawAuthenticateDevice or cryptoAuthenticateDevice. Firmware updates will require authentication too</description></item><item><description>KEY_ENCRYPTION - if set, magnetic card data will come encrypted via magneticCardEncryptedData or magneticCardEncryptedRawData keyIDthe key type to set - KEY_AUTHENTICATION or KEY_ENCRYPTION key32 bytes AES256 key to set oldKey32 bytes AES256 key that was previously used, or null if there was no previous key. The old key should match the new key, i.e. if you are setting KEY_ENCRYPTION, then you should pass the old KEY_ENCRYPTION. keyVersion- the version of the key. On firmware versions less than 2.43 this parameter is ignored and key version is considered to be 0x00000000. Key version is useful for the program to determine what key is inside the head. keyFlags- optional key flags, supported on ver 2.58 and onward</description></item><item><description>KEY_AUTHENTICATION: BIT 1If set to 1, scanning barcodes, reading magnetic card and using the bluetooth module are locked and have to be unlocked with cryptoAuthenticateHost/cryptoRawAuthenticateHost upon every reinsert of the device </description></item><item><description>KEY_ENCRYPTION: No flags are supported errorpointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information TRUE if function succeeded, FALSE otherwise </description></item></list></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Used to store AES256 keys into <see cref="T:LineaProSdk.Linea" /> internal memory. Valid keys that can be set:<list type="bullet"><item><description>KEY_AUTHENTICATION - if set, you can use authentication functions - cryptoRawAuthenticateDevice or cryptoAuthenticateDevice. Firmware updates will require authentication too</description></item><item><description>KEY_ENCRYPTION - if set, magnetic card data will come encrypted via magneticCardEncryptedData or magneticCardEncryptedRawData keyIDthe key type to set - KEY_AUTHENTICATION or KEY_ENCRYPTION key32 bytes AES256 key to set oldKey32 bytes AES256 key that was previously used, or null if there was no previous key. The old key should match the new key, i.e. if you are setting KEY_ENCRYPTION, then you should pass the old KEY_ENCRYPTION. keyVersion- the version of the key. On firmware versions less than 2.43 this parameter is ignored and key version is considered to be 0x00000000. Key version is useful for the program to determine what key is inside the head. keyFlags- optional key flags, supported on ver 2.58 and onward</description></item><item><description>KEY_AUTHENTICATION: BIT 1If set to 1, scanning barcodes, reading magnetic card and using the bluetooth module are locked and have to be unlocked with cryptoAuthenticateHost/cryptoRawAuthenticateHost upon every reinsert of the device </description></item><item><description>KEY_ENCRYPTION: No flags are supported errorpointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information TRUE if function succeeded, FALSE otherwise </description></item></list></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegate">
      <MemberSignature Language="C#" Value="public LineaProSdk.LineaDelegate Delegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class LineaProSdk.LineaDelegate Delegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>LineaProSdk.LineaDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Delegates">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject[] Delegates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject[] Delegates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("delegates")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Provides a list of currently registered delegates </para>
        </summary>
        <value>To be added.</value>
        <remarks>
          <para>Provides a list of currently registered delegates </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeviceModel">
      <MemberSignature Language="C#" Value="public virtual string DeviceModel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeviceModel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("deviceModel", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeviceName">
      <MemberSignature Language="C#" Value="public virtual string DeviceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeviceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("deviceName", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public virtual void Disconnect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Disconnect() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("disconnect")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <para>Stops the sdk from trying to connect to <see cref="T:LineaProSdk.Linea" /> and breaks existing connection. </para>
        </summary>
        <remarks>
          <para>Stops the sdk from trying to connect to <see cref="T:LineaProSdk.Linea" /> and breaks existing connection. </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrConfigMaskedDataShowExpiration">
      <MemberSignature Language="C#" Value="public virtual bool EmsrConfigMaskedDataShowExpiration (bool showExpiration, int unmaskedDigitsAtStart, int unmaskedDigitsAtEnd, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EmsrConfigMaskedDataShowExpiration(bool showExpiration, int32 unmaskedDigitsAtStart, int32 unmaskedDigitsAtEnd, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrConfigMaskedDataShowExpiration:unmaskedDigitsAtStart:unmaskedDigitsAtEnd:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="showExpiration" Type="System.Boolean" />
        <Parameter Name="unmaskedDigitsAtStart" Type="System.Int32" />
        <Parameter Name="unmaskedDigitsAtEnd" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="showExpiration">if set to TRUE, expiration date will be shown in clear text, otherwise will be masked </param>
        <param name="unmaskedDigitsAtStart">the number of digits to show in clear text at the start of the PAN, range from 0 to 6 (default is 4) </param>
        <param name="unmaskedDigitsAtEnd">the number of digits to show in clear text at the end of the PAN, range from 0, to 4 (default is 4) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Fine-tunes which part of the card data will be masked, and which will be sent in clear text for display/print purposes <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Fine-tunes which part of the card data will be masked, and which will be sent in clear text for display/print purposes <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrGetDeviceModel">
      <MemberSignature Language="C#" Value="public virtual string EmsrGetDeviceModel (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string EmsrGetDeviceModel(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrGetDeviceModel:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns head's model <para>head's model as string </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns head's model <para>head's model as string </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrGetDUKPTSerial">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData EmsrGetDUKPTSerial (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData EmsrGetDUKPTSerial(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrGetDUKPTSerial:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns DUKPT serial number, if DUKPT key is set <para>serial number or nil if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns DUKPT serial number, if DUKPT key is set <para>serial number or nil if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrGetFirmwareInformation">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSDictionary EmsrGetFirmwareInformation (MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSDictionary EmsrGetFirmwareInformation(class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrGetFirmwareInformation:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <param name="error">To be added.</param>
        <summary>
          <para>Returns information about the specified head firmware data. Based on it, and the current head's name and firmware version you can chose to update or not the head's firmware <para>dictionary containing extracted data or nil if the data is invalid. Keys contained are: <table rows="3" cols="2"><row><entry thead="no"><para>"deviceModel"</para></entry><entry thead="no"><para>Head's model, for example "EMSR-DEA" </para></entry></row><row><entry thead="no"><para>"firmwareRevision"</para></entry><entry thead="no"><para>Firmware revision as string, for example 1.07 </para></entry></row><row><entry thead="no"><para>"firmwareRevisionNumber"</para></entry><entry thead="no"><para>Firmware revision as number MAJOR*100+MINOR, i.e. 1.07 will be returned as 107 </para></entry></row></table></para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns information about the specified head firmware data. Based on it, and the current head's name and firmware version you can chose to update or not the head's firmware <para>dictionary containing extracted data or nil if the data is invalid. Keys contained are: <table rows="3" cols="2"><row><entry thead="no"><para>"deviceModel"</para></entry><entry thead="no"><para>Head's model, for example "EMSR-DEA" </para></entry></row><row><entry thead="no"><para>"firmwareRevision"</para></entry><entry thead="no"><para>Firmware revision as string, for example 1.07 </para></entry></row><row><entry thead="no"><para>"firmwareRevisionNumber"</para></entry><entry thead="no"><para>Firmware revision as number MAJOR*100+MINOR, i.e. 1.07 will be returned as 107 </para></entry></row></table></para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrGetFirmwareVersion">
      <MemberSignature Language="C#" Value="public virtual bool EmsrGetFirmwareVersion (out int version, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EmsrGetFirmwareVersion(int32 version, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrGetFirmwareVersion:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="version">integer, where firmware version is stored upon success </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns head's firmware version as number MAJOR*100+MINOR, i.e. version 1.05 will be sent as 105 <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns head's firmware version as number MAJOR*100+MINOR, i.e. version 1.05 will be sent as 105 <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrGetKeyVersion">
      <MemberSignature Language="C#" Value="public virtual bool EmsrGetKeyVersion (int keyID, out int keyVersion, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EmsrGetKeyVersion(int32 keyID, int32 keyVersion, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrGetKeyVersion:keyVersion:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyID" Type="System.Int32" />
        <Parameter Name="keyVersion" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyID">the ID of the key to get the version, one of the KEY_* constants </param>
        <param name="keyVersion">- pointer to integer, where key version will be returned upon success. Key version can be 0. </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Retrieves the key version (if any) of a loaded key <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Retrieves the key version (if any) of a loaded key <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrGetSecurityVersion">
      <MemberSignature Language="C#" Value="public virtual bool EmsrGetSecurityVersion (out int version, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EmsrGetSecurityVersion(int32 version, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrGetSecurityVersion:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="version">integer, where firmware version is stored upon success </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns head's security version as number MAJOR*100+MINOR, i.e. version 1.05 will be sent as 105. Security version is the version of the certificated security kernel. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns head's security version as number MAJOR*100+MINOR, i.e. version 1.05 will be sent as 105. Security version is the version of the certificated security kernel. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrGetSerialNumber">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData EmsrGetSerialNumber (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData EmsrGetSerialNumber(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrGetSerialNumber:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Return head's unique serial number as byte array <para>serial number or nil if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Return head's unique serial number as byte array <para>serial number or nil if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrGetSupportedEncryptions">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject[] EmsrGetSupportedEncryptions (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSObject[] EmsrGetSupportedEncryptions(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrGetSupportedEncryptions:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">firmware file data </param>
        <summary>
          <para>Returns supported encryption algorhtms by the encrypted head. <para>an array of supported algorithms or nil if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns supported encryption algorhtms by the encrypted head. <para>an array of supported algorithms or nil if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrIsTampered">
      <MemberSignature Language="C#" Value="public virtual bool EmsrIsTampered (out bool tampered, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EmsrIsTampered(bool tampered, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrIsTampered:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tampered" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="tampered">if there is no connection to </param>
        <param name="error">if there is no connection to the encrypted head </param>
        <summary>
          <para>Checks if the head was tampered or not. If the head's tamper protection have activated, the device should be sent to service for checks <para>true if the head was tampered and not operational </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Checks if the head was tampered or not. If the head's tamper protection have activated, the device should be sent to service for checks <para>true if the head was tampered and not operational </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrLoadInitialKey">
      <MemberSignature Language="C#" Value="public virtual bool EmsrLoadInitialKey (MonoTouch.Foundation.NSData keyData, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EmsrLoadInitialKey(class MonoTouch.Foundation.NSData keyData, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrLoadInitialKey:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyData">an array, that consists of:BLOCK IDENT - 1 byte, set to 0x29KEY ID - the ID of the key to set, put KEY_TMK_AES (0x10)KEY VERSION - the version of the key in high to low order, 4 bytes, cannot be 0KEY - the key data, 16 bytesHASH - SHA256 of the previous bytes (BLOCK IDENT, KEY ID, KEY VERSION and KEY) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Loads Terminal Master Key (TMK) or reenable after tampering. This command is enabled only if the device is in tamper mode or there is no TMK key yet. If the command is executed in normal mode an error will be returned. To reenable the device after tampering the old TMK key must be passed as an argument. If the keys do not match error will be returned. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Loads Terminal Master Key (TMK) or reenable after tampering. This command is enabled only if the device is in tamper mode or there is no TMK key yet. If the command is executed in normal mode an error will be returned. To reenable the device after tampering the old TMK key must be passed as an argument. If the keys do not match error will be returned. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrLoadKey">
      <MemberSignature Language="C#" Value="public virtual bool EmsrLoadKey (MonoTouch.Foundation.NSData keyData, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EmsrLoadKey(class MonoTouch.Foundation.NSData keyData, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrLoadKey:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyData">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <param name="error">To be added.</param>
        <summary>
          <para>Loads new key, in plain or encrypted with already loaded AES256 Key Encryption Key (KEK). Plain text loading works only the first time the specified key is loaded and is recommended only in secure environment. For normal usage the new key should be encrypted with the Key Encryption Key (KEK). The command is unavailable if the device is tampred. <linebreak />
If using KEY_EH_AES256_LOADING, then KEY + HASH have to be put inside the packet encrypted with AES256 using key KEY_EH_AES256_LOADING. SHA256 is calculated on the unencrypted data. The head decrypts the data and then calculates and compares the hash. If the calculated SHA does not match the SHA sent with the command, the key excahnge is rejected and error is returned. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Loads new key, in plain or encrypted with already loaded AES256 Key Encryption Key (KEK). Plain text loading works only the first time the specified key is loaded and is recommended only in secure environment. For normal usage the new key should be encrypted with the Key Encryption Key (KEK). The command is unavailable if the device is tampred. <linebreak />
If using KEY_EH_AES256_LOADING, then KEY + HASH have to be put inside the packet encrypted with AES256 using key KEY_EH_AES256_LOADING. SHA256 is calculated on the unencrypted data. The head decrypts the data and then calculates and compares the hash. If the calculated SHA does not match the SHA sent with the command, the key excahnge is rejected and error is returned. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrSetEncryption">
      <MemberSignature Language="C#" Value="public virtual bool EmsrSetEncryption (int encryption, MonoTouch.Foundation.NSData parameters, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EmsrSetEncryption(int32 encryption, class MonoTouch.Foundation.NSData parameters, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrSetEncryption:params:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encryption" Type="System.Int32" />
        <Parameter Name="parameters" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="encryption">encryption algorhtm used, one o fthe ALG_* constants </param>
        <param name="parameters">optional algorithm parameters, currently no algorithm supports these </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Selects the prefered encryption algorithm. When card is swiped, it will be encrypted by it and sent via magneticCardEncryptedData delegate <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Selects the prefered encryption algorithm. When card is swiped, it will be encrypted by it and sent via magneticCardEncryptedData delegate <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmsrUpdateFirmware">
      <MemberSignature Language="C#" Value="public virtual bool EmsrUpdateFirmware (MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EmsrUpdateFirmware(class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("emsrUpdateFirmware:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">firmware file data </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs firmware update on the encrypted head. DO NOT INTERRUPT THE COMMUNICATION DURING THE FIRMWARE UPDATE! <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs firmware update on the encrypted head. DO NOT INTERRUPT THE COMMUNICATION DURING THE FIRMWARE UPDATE! <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtCloseSerialPort">
      <MemberSignature Language="C#" Value="public virtual bool ExtCloseSerialPort (int port, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ExtCloseSerialPort(int32 port, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("extCloseSerialPort:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="port">the port number, currently only 1 is used </param>
        <param name="error">returns error information, you can pass nil if you don't want it </param>
        <summary>
          <para>Closes the external serial port opened with extOpenSerialPort <para>TRUE upon success, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Closes the external serial port opened with extOpenSerialPort <para>TRUE upon success, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtOpenSerialPort">
      <MemberSignature Language="C#" Value="public virtual bool ExtOpenSerialPort (int port, int baudRate, int parity, int dataBits, int stopBits, int flowControl, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ExtOpenSerialPort(int32 port, int32 baudRate, int32 parity, int32 dataBits, int32 stopBits, int32 flowControl, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("extOpenSerialPort:baudRate:parity:dataBits:stopBits:flowControl:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.Int32" />
        <Parameter Name="dataBits" Type="System.Int32" />
        <Parameter Name="stopBits" Type="System.Int32" />
        <Parameter Name="flowControl" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="port">the port number, currently only 1 is used </param>
        <param name="baudRate">serial baud rate </param>
        <param name="parity">serial parity, one of the PARITY_* constants (currenty only PARITY_NONE is supported) </param>
        <param name="dataBits">serial data bits, one of the DATABITS_* constants (currently only DATABITS_8 is supported) </param>
        <param name="stopBits">serial stop bits, one of the STOPBITS_* constants (currently only STOPBITS_1 is supported) </param>
        <param name="flowControl">serial flow control, one of the FLOW_* constants (currently only FLOW_NONE is supported) </param>
        <param name="error">returns error information, you can pass nil if you don't want it </param>
        <summary>
          <para>Opens the external serial port with specified settings. <para>On <see cref="T:LineaProSdk.Linea" /> Tab opening the serial port disables barcode scanner for the duration </para><para>TRUE upon success, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Opens the external serial port with specified settings. <para>On <see cref="T:LineaProSdk.Linea" /> Tab opening the serial port disables barcode scanner for the duration </para><para>TRUE upon success, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtReadSerialPort">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData ExtReadSerialPort (int port, int length, double timeout, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData ExtReadSerialPort(int32 port, int32 length, float64 timeout, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("extReadSerialPort:length:timeout:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="timeout" Type="System.Double" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="port">the port number, currently only 1 is used </param>
        <param name="length">the maximum amount of data to read </param>
        <param name="timeout">timeout in seconds, passing 0 reads and returns the bytes currently in the buffer </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Reads data from the connected remote device via serial port. <para>NSData with bytes received if function succeeded, nil otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Reads data from the connected remote device via serial port. <para>NSData with bytes received if function succeeded, nil otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtWriteSerialPort">
      <MemberSignature Language="C#" Value="public virtual bool ExtWriteSerialPort (int port, MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ExtWriteSerialPort(int32 port, class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("extWriteSerialPort:data:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="port">the port number, currently only 1 is used </param>
        <param name="data">data bytes to write </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sends data to the connected remote device via serial port. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sends data to the connected remote device via serial port. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaRead">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData FelicaRead (int cardIndex, int startBlock, int length, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData FelicaRead(int32 cardIndex, int32 startBlock, int32 length, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaRead:startBlock:length:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="startBlock" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="startBlock">the starting block to read from </param>
        <param name="length">the number of bytes to read, this must be multiple of block size (can be taken from the card info that is coming with rfCardDetected call) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Reads one more more blocks of data from FeliCa card. <para>NSData object containing the data received or nil if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Reads one more more blocks of data from FeliCa card. <para>NSData object containing the data received or nil if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaSmartTagClearScreen">
      <MemberSignature Language="C#" Value="public virtual bool FelicaSmartTagClearScreen (int cardIndex, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool FelicaSmartTagClearScreen(int32 cardIndex, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaSmartTagClearScreen:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="error">upon successful execution, battery status will be returned here, one of FELICA_SMARTTAG_BATTERY_* constants </param>
        <summary>
          <para>Clears the screen of FeliCa SmartTag <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Clears the screen of FeliCa SmartTag <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaSmartTagDisplayLayout">
      <MemberSignature Language="C#" Value="public virtual bool FelicaSmartTagDisplayLayout (int cardIndex, int layout, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool FelicaSmartTagDisplayLayout(int32 cardIndex, int32 layout, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaSmartTagDisplayLayout:layout:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="layout" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="layout">layout index (1-12) of the previously stored image </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Displays previously stored layout <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Displays previously stored layout <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaSmartTagDrawImage">
      <MemberSignature Language="C#" Value="public virtual bool FelicaSmartTagDrawImage (int cardIndex, MonoTouch.UIKit.UIImage image, int topLeftX, int topLeftY, int drawMode, int layout, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool FelicaSmartTagDrawImage(int32 cardIndex, class MonoTouch.UIKit.UIImage image, int32 topLeftX, int32 topLeftY, int32 drawMode, int32 layout, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaSmartTagDrawImage:image:topLeftX:topLeftY:drawMode:layout:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="image" Type="MonoTouch.UIKit.UIImage" />
        <Parameter Name="topLeftX" Type="System.Int32" />
        <Parameter Name="topLeftY" Type="System.Int32" />
        <Parameter Name="drawMode" Type="System.Int32" />
        <Parameter Name="layout" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="image">image to draw </param>
        <param name="topLeftX">- topleft X coordinate in pixels </param>
        <param name="topLeftY">- topleft Y coordinate in pixels </param>
        <param name="drawMode">draw mode, one of the FELICA_SMARTTAG_DRAW_* constants </param>
        <param name="layout">only used when drawMode is FELICA_SMARTTAG_DRAW_USE_LAYOUT, it specifies the index of the layout (1-12) of the previously stored image </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Draws image on FeliCa SmartTag's screen. The screen is 200x96 pixels. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Draws image on FeliCa SmartTag's screen. The screen is 200x96 pixels. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaSmartTagGetBatteryStatus">
      <MemberSignature Language="C#" Value="public virtual bool FelicaSmartTagGetBatteryStatus (int cardIndex, out int status, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool FelicaSmartTagGetBatteryStatus(int32 cardIndex, int32 status, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaSmartTagGetBatteryStatus:status:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="status" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="status">upon successful execution, battery status will be returned here, one of FELICA_SMARTTAG_BATTERY_* constants </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns FeliCa SmartTag battery status <para>Call this function before any other SmartTag </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns FeliCa SmartTag battery status <para>Call this function before any other SmartTag </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaSmartTagRead">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData FelicaSmartTagRead (int cardIndex, int address, int length, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData FelicaSmartTagRead(int32 cardIndex, int32 address, int32 length, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaSmartTagRead:address:length:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="address" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="address">the address of the card to read from, refer to SmartTag documentation </param>
        <param name="length">of the data to read, note that the data does not need to be aligned to block size </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Writes data in FeliCa SmartTag. <para>NSData object containing the data received or nil if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Writes data in FeliCa SmartTag. <para>NSData object containing the data received or nil if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaSmartTagSaveLayout">
      <MemberSignature Language="C#" Value="public virtual bool FelicaSmartTagSaveLayout (int cardIndex, int layout, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool FelicaSmartTagSaveLayout(int32 cardIndex, int32 layout, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaSmartTagSaveLayout:layout:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="layout" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="layout">layout index (1-12) to which the currently displayed image will be saved </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Saves the current display as layout number <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Saves the current display as layout number <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaSmartTagWaitCompletion">
      <MemberSignature Language="C#" Value="public virtual bool FelicaSmartTagWaitCompletion (int cardIndex, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool FelicaSmartTagWaitCompletion(int32 cardIndex, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaSmartTagWaitCompletion:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Waits for FeliCa SmartTag to complete current operation. Waiting is generally not needed, but needed in case for example drawing an image and then saving the layout, you need to wait for the image to be drawn. Write operation forces waiting internally. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Waits for FeliCa SmartTag to complete current operation. Waiting is generally not needed, but needed in case for example drawing an image and then saving the layout, you need to wait for the image to be drawn. Write operation forces waiting internally. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaSmartTagWrite">
      <MemberSignature Language="C#" Value="public virtual int FelicaSmartTagWrite (int cardIndex, int address, MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 FelicaSmartTagWrite(int32 cardIndex, int32 address, class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaSmartTagWrite:address:data:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="address" Type="System.Int32" />
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="address">the address of the card to write to, refer to SmartTag documentation </param>
        <param name="data">data to write, note that the data does not need to be aligned to block size </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Writes data in FeliCa SmartTag. <para>number of bytes actually written or 0 if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Writes data in FeliCa SmartTag. <para>number of bytes actually written or 0 if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FelicaWrite">
      <MemberSignature Language="C#" Value="public virtual int FelicaWrite (int cardIndex, int startBlock, MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 FelicaWrite(int32 cardIndex, int32 startBlock, class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("felicaWrite:startBlock:data:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="startBlock" Type="System.Int32" />
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="startBlock">the starting block to write to </param>
        <param name="data">the data to write, it must be multiple of block size (can be taken from the card info that is coming with rfCardDetected call) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Writes one more more blocks of data to FeliCa card. <para>number of bytes actually written or 0 if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Writes one more more blocks of data to FeliCa card. <para>number of bytes actually written or 0 if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FirmwareRevision">
      <MemberSignature Language="C#" Value="public virtual string FirmwareRevision { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FirmwareRevision" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("firmwareRevision", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBatteryCapacity">
      <MemberSignature Language="C#" Value="public virtual bool GetBatteryCapacity (out int capacity, out float voltage, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetBatteryCapacity(int32 capacity, float32 voltage, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("getBatteryCapacity:voltage:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="voltage" Type="System.Single&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="capacity">returns battery capacity in percents, ranging from 0 when battery is dead to 100 when fully charged. Pass nil if you don't want that information </param>
        <param name="voltage">returns battery voltage in Volts, pass nil if you don't want that information </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns <see cref="T:LineaProSdk.Linea" />'s battery capacity <para>Reading battery voltages during charging (both <see cref="T:LineaProSdk.Linea" /> charing and <see cref="T:LineaProSdk.Linea" /> charging the iPod) is unreliable! </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns <see cref="T:LineaProSdk.Linea" />'s battery capacity <para>Reading battery voltages during charging (both <see cref="T:LineaProSdk.Linea" /> charing and <see cref="T:LineaProSdk.Linea" /> charging the iPod) is unreliable! </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharging">
      <MemberSignature Language="C#" Value="public virtual bool GetCharging (out bool charging, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetCharging(bool charging, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("getCharging:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charging" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="charging">returns TRUE if charging is enabled (from internal battery, external charging is omitted) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns if <see cref="T:LineaProSdk.Linea" /> is charging the iOS device from it's own battery. <see cref="T:LineaProSdk.Linea" /> firmware versions prior to 2.13 will return true if external charge is attached, 2.13 and later will return only if <see cref="T:LineaProSdk.Linea" />'s own battery is used for charging. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns if <see cref="T:LineaProSdk.Linea" /> is charging the iOS device from it's own battery. <see cref="T:LineaProSdk.Linea" /> firmware versions prior to 2.13 will return true if external charge is attached, 2.13 and later will return only if <see cref="T:LineaProSdk.Linea" />'s own battery is used for charging. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirmwareFileInformation">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSDictionary GetFirmwareFileInformation (MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSDictionary GetFirmwareFileInformation(class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("getFirmwareFileInformation:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">- firmware data </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns information about the specified firmware data. Based on it, and the connected <see cref="T:LineaProSdk.Linea" />'s name, model and firmware version you can chose to update or not the <see cref="T:LineaProSdk.Linea" />'s firmware <para>firmware information if function succeeded, nil otherwise. See Info* constants for possible keys in the returned dictionary. </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns information about the specified firmware data. Based on it, and the connected <see cref="T:LineaProSdk.Linea" />'s name, model and firmware version you can chose to update or not the <see cref="T:LineaProSdk.Linea" />'s firmware <para>firmware information if function succeeded, nil otherwise. See Info* constants for possible keys in the returned dictionary. </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSyncButtonMode">
      <MemberSignature Language="C#" Value="public virtual bool GetSyncButtonMode (out int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetSyncButtonMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("getSyncButtonMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">returns sync button mode, one of the: BUTTON_DISABLED's will not perform synchronization when you press and hold the button for 3 seconds BUTTON_ENABLED's will perform synchronization when you press and hold the button for 3 seconds </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Returns the current sync button mode. See setSyncButtonMode for more detailed description. This setting is stored into flash memory and will persist. <para>Although this function was made for <see cref="T:LineaProSdk.Linea" /> 1, that had hardware button to enter sync mode, it still works for enabling/disabling automated sync on <see cref="T:LineaProSdk.Linea" /> 4 and onward </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns the current sync button mode. See setSyncButtonMode for more detailed description. This setting is stored into flash memory and will persist. <para>Although this function was made for <see cref="T:LineaProSdk.Linea" /> 1, that had hardware button to enter sync mode, it still works for enabling/disabling automated sync on <see cref="T:LineaProSdk.Linea" /> 4 and onward </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HardwareRevision">
      <MemberSignature Language="C#" Value="public virtual string HardwareRevision { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HardwareRevision" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("hardwareRevision", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Iso15693GetBlocksSecurityStatus">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData Iso15693GetBlocksSecurityStatus (int cardIndex, int startBlock, int nBlocks, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData Iso15693GetBlocksSecurityStatus(int32 cardIndex, int32 startBlock, int32 nBlocks, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("iso15693GetBlocksSecurityStatus:startBlock:nBlocks:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="startBlock" Type="System.Int32" />
        <Parameter Name="nBlocks" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="startBlock">the starting block to read from </param>
        <param name="nBlocks">the number of blocks to get the security status </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Reads the security status of one more more blocks from ISO 15693 card. <para>NSData object containing the data received or nil if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Reads the security status of one more more blocks from ISO 15693 card. <para>NSData object containing the data received or nil if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iso15693LockAFI">
      <MemberSignature Language="C#" Value="public virtual bool Iso15693LockAFI (int cardIndex, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Iso15693LockAFI(int32 cardIndex, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("iso15693LockAFI:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Locks ISO 15693 AFI preventing further changes. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Locks ISO 15693 AFI preventing further changes. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iso15693LockBlock">
      <MemberSignature Language="C#" Value="public virtual bool Iso15693LockBlock (int cardIndex, int block, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Iso15693LockBlock(int32 cardIndex, int32 block, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("iso15693LockBlock:block:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="block" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="block">the block index to lock </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Locks a single ISO 15693 card block. Locked blocks cannot be written upon anymore. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Locks a single ISO 15693 card block. Locked blocks cannot be written upon anymore. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iso15693LockDSFID">
      <MemberSignature Language="C#" Value="public virtual bool Iso15693LockDSFID (int cardIndex, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Iso15693LockDSFID(int32 cardIndex, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("iso15693LockDSFID:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Locks ISO 15693 card DSFID preventing further changes. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Locks ISO 15693 card DSFID preventing further changes. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iso15693Read">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData Iso15693Read (int cardIndex, int startBlock, int length, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData Iso15693Read(int32 cardIndex, int32 startBlock, int32 length, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("iso15693Read:startBlock:length:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="startBlock" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="startBlock">the starting block to read from </param>
        <param name="length">the number of bytes to read, this must be multiple of block size (can be taken from the card info that is coming with rfCardDetected call) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Reads one more more blocks of data from ISO 15693 card. <para>NSData object containing the data received or nil if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Reads one more more blocks of data from ISO 15693 card. <para>NSData object containing the data received or nil if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iso15693Write">
      <MemberSignature Language="C#" Value="public virtual int Iso15693Write (int cardIndex, int startBlock, MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Iso15693Write(int32 cardIndex, int32 startBlock, class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("iso15693Write:startBlock:data:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="startBlock" Type="System.Int32" />
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="startBlock">the starting block to write to </param>
        <param name="data">the data to write, it must be multiple of block size (can be taken from the card info that is coming with rfCardDetected call) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Writes one more more blocks of data to ISO 15693 card. <para>number of bytes actually written or 0 if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Writes one more more blocks of data to ISO 15693 card. <para>number of bytes actually written or 0 if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iso15693WriteAFI">
      <MemberSignature Language="C#" Value="public virtual bool Iso15693WriteAFI (int cardIndex, byte afi, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Iso15693WriteAFI(int32 cardIndex, unsigned int8 afi, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("iso15693WriteAFI:afi:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="afi" Type="System.Byte" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="afi">new AFI value </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Changes ISO 15693 card AFI. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Changes ISO 15693 card AFI. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Iso15693WriteDSFID">
      <MemberSignature Language="C#" Value="public virtual bool Iso15693WriteDSFID (int cardIndex, byte dsfid, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Iso15693WriteDSFID(int32 cardIndex, unsigned int8 dsfid, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("iso15693WriteDSFID:dsfid:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="dsfid" Type="System.Byte" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="dsfid">new DSFID value </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Changes ISO 15693 card DSFID. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Changes ISO 15693 card DSFID. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPresent">
      <MemberSignature Language="C#" Value="public virtual bool IsPresent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPresent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("isPresent")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MfAuthByKey">
      <MemberSignature Language="C#" Value="public virtual bool MfAuthByKey (int cardIndex, sbyte type, int address, MonoTouch.Foundation.NSData key, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MfAuthByKey(int32 cardIndex, int8 type, int32 address, class MonoTouch.Foundation.NSData key, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("mfAuthByKey:type:address:key:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="type" Type="System.SByte" />
        <Parameter Name="address" Type="System.Int32" />
        <Parameter Name="key" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="type">key type, either 'A' or 'B' </param>
        <param name="address">the address of the block to authenticate </param>
        <param name="key">6 bytes key </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Authenticate mifare card block with direct key data. This is less secure method, as it requires the key to be present in the program, the prefered way is to store a key once in a secure environment and then authenticate using the stored key. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Authenticate mifare card block with direct key data. This is less secure method, as it requires the key to be present in the program, the prefered way is to store a key once in a secure environment and then authenticate using the stored key. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MfAuthByStoredKey">
      <MemberSignature Language="C#" Value="public virtual bool MfAuthByStoredKey (int cardIndex, sbyte type, int address, int keyIndex, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MfAuthByStoredKey(int32 cardIndex, int8 type, int32 address, int32 keyIndex, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("mfAuthByStoredKey:type:address:keyIndex:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="type" Type="System.SByte" />
        <Parameter Name="address" Type="System.Int32" />
        <Parameter Name="keyIndex" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="type">key type, either 'A' or 'B' </param>
        <param name="address">the address of the block to authenticate </param>
        <param name="keyIndex">the index of the stored key, you can have up to 8 keys stored (0-7) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Authenticate mifare card block with previously stored key. This the prefered method, as no key needs to reside in application. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Authenticate mifare card block with previously stored key. This the prefered method, as no key needs to reside in application. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MfRead">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSData MfRead (int cardIndex, int address, int length, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSData MfRead(int32 cardIndex, int32 address, int32 length, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("mfRead:address:length:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="address" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="address">the address of the block to read </param>
        <param name="length">the number of bytes to read, this must be multiple of block size (16 bytes) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Reads one more more blocks of data from Mifare Classic/Ultralight cards. A single read operation gets 16 bytes of data, so you can pass 32 on length to read 2 blocks, etc <para>NSData object containing the data received or nil if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Reads one more more blocks of data from Mifare Classic/Ultralight cards. A single read operation gets 16 bytes of data, so you can pass 32 on length to read 2 blocks, etc <para>NSData object containing the data received or nil if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MfStoreKeyIndex">
      <MemberSignature Language="C#" Value="public virtual bool MfStoreKeyIndex (int keyIndex, sbyte type, MonoTouch.Foundation.NSData key, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MfStoreKeyIndex(int32 keyIndex, int8 type, class MonoTouch.Foundation.NSData key, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("mfStoreKeyIndex:type:key:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIndex" Type="System.Int32" />
        <Parameter Name="type" Type="System.SByte" />
        <Parameter Name="key" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyIndex">the index of the key, you can have up to 8 keys stored (0-7) </param>
        <param name="type">key type, either 'A' or 'B' </param>
        <param name="key">6 bytes key </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Store key in the internal module memory for later use <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Store key in the internal module memory for later use <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MfUlcAuthByKey">
      <MemberSignature Language="C#" Value="public virtual bool MfUlcAuthByKey (int cardIndex, MonoTouch.Foundation.NSData key, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MfUlcAuthByKey(int32 cardIndex, class MonoTouch.Foundation.NSData key, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("mfUlcAuthByKey:key:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="key" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="key">16 bytes 3DES key to authenticate with </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Performs 3DES authentication of Mifare Ultralight C card using the given key <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Performs 3DES authentication of Mifare Ultralight C card using the given key <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MfUlcSetKey">
      <MemberSignature Language="C#" Value="public virtual bool MfUlcSetKey (int cardIndex, MonoTouch.Foundation.NSData key, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MfUlcSetKey(int32 cardIndex, class MonoTouch.Foundation.NSData key, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("mfUlcSetKey:key:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="key" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="key">16 bytes 3DES key to set </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sets the 3DES key of Mifare Ultralight C cards <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sets the 3DES key of Mifare Ultralight C cards <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MfWrite">
      <MemberSignature Language="C#" Value="public virtual int MfWrite (int cardIndex, int address, MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 MfWrite(int32 cardIndex, int32 address, class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("mfWrite:address:data:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="address" Type="System.Int32" />
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="address">the address of the block to write </param>
        <param name="data">the data to write, must be multiple of the block size (16 bytes) </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Writes one more more blocks of data to Mifare Classic/Ultralight cards. A single write operation stores 16 bytes of data, so you can pass 32 on length to write 2 blocks, etc <para>number of bytes actually written or 0 if an error occured </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Writes one more more blocks of data to Mifare Classic/Ultralight cards. A single write operation stores 16 bytes of data, so you can pass 32 on length to write 2 blocks, etc <para>number of bytes actually written or 0 if an error occured </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MsDisable">
      <MemberSignature Language="C#" Value="public virtual bool MsDisable (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MsDisable(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("msDisable:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Disables magnetic card scanning started with msEnable <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Disables magnetic card scanning started with msEnable <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MsEnable">
      <MemberSignature Language="C#" Value="public virtual bool MsEnable (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MsEnable(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("msEnable:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Enables reading of magnetic cards. Whenever a card is successfully read, the magneticCardData delegate will be called. Current magnetic card heads used in <see cref="T:LineaProSdk.Linea" /> consume so little power, that there is no drawback in leaving scanning enabled all the time. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Enables reading of magnetic cards. Whenever a card is successfully read, the magneticCardData delegate will be called. Current magnetic card heads used in <see cref="T:LineaProSdk.Linea" /> consume so little power, that there is no drawback in leaving scanning enabled all the time. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MsGetCardDataMode">
      <MemberSignature Language="C#" Value="public virtual bool MsGetCardDataMode (out int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MsGetCardDataMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("msGetCardDataMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <param name="error">To be added.</param>
        <summary>
          <para>Returns the current magnetic card data mode. This setting is not persistent and is best to configure it upon connect. <para>card data mode, one of the: <table rows="2" cols="2"><row><entry thead="no"><para>MS_PROCESSED_CARD_DATA</para></entry><entry thead="no"><para>Card data will be processed and will be returned via call to magneticCardData </para></entry></row><row><entry thead="no"><para>MS_RAW_CARD_DATA</para></entry><entry thead="no"><para>Card data will not be processed and will be returned via call to magneticCardRawData </para></entry></row></table></para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Returns the current magnetic card data mode. This setting is not persistent and is best to configure it upon connect. <para>card data mode, one of the: <table rows="2" cols="2"><row><entry thead="no"><para>MS_PROCESSED_CARD_DATA</para></entry><entry thead="no"><para>Card data will be processed and will be returned via call to magneticCardData </para></entry></row><row><entry thead="no"><para>MS_RAW_CARD_DATA</para></entry><entry thead="no"><para>Card data will not be processed and will be returned via call to magneticCardRawData </para></entry></row></table></para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MsProcessFinancialCard">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSDictionary MsProcessFinancialCard (string track1, string track2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class MonoTouch.Foundation.NSDictionary MsProcessFinancialCard(string track1, string track2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("msProcessFinancialCard:track2:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="track1" Type="System.String" />
        <Parameter Name="track2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="track1">if there is no connection to </param>
        <param name="track2">To be added.</param>
        <summary>
          <para>Helper function to parse financial card and extract the data - name, number, expiration date. The function will extract as much information as possible. <para>dictionary containing extracted data or nil if the data is invalid. Keys contained are: <table rows="8" cols="2"><row><entry thead="no"><para>"accountNumber"</para></entry><entry thead="no"><para>Account number </para></entry></row><row><entry thead="no"><para>"cardholderName"</para></entry><entry thead="no"><para>Cardholder name, as stored in the card </para></entry></row><row><entry thead="no"><para>"expirationYear"</para></entry><entry thead="no"><para>Expiration date - year </para></entry></row><row><entry thead="no"><para>"expirationMonth"</para></entry><entry thead="no"><para>Expiration date - month </para></entry></row><row><entry thead="no"><para>"serviceCode"</para></entry><entry thead="no"><para>Service code (if any) </para></entry></row><row><entry thead="no"><para>"discretionaryData"</para></entry><entry thead="no"><para>Discretionary data (if any) </para></entry></row><row><entry thead="no"><para>"firstName"</para></entry><entry thead="no"><para>Extracted cardholder's first name </para></entry></row><row><entry thead="no"><para>"lastName"</para></entry><entry thead="no"><para>Extracted cardholder's last name </para></entry></row></table></para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Helper function to parse financial card and extract the data - name, number, expiration date. The function will extract as much information as possible. <para>dictionary containing extracted data or nil if the data is invalid. Keys contained are: <table rows="8" cols="2"><row><entry thead="no"><para>"accountNumber"</para></entry><entry thead="no"><para>Account number </para></entry></row><row><entry thead="no"><para>"cardholderName"</para></entry><entry thead="no"><para>Cardholder name, as stored in the card </para></entry></row><row><entry thead="no"><para>"expirationYear"</para></entry><entry thead="no"><para>Expiration date - year </para></entry></row><row><entry thead="no"><para>"expirationMonth"</para></entry><entry thead="no"><para>Expiration date - month </para></entry></row><row><entry thead="no"><para>"serviceCode"</para></entry><entry thead="no"><para>Service code (if any) </para></entry></row><row><entry thead="no"><para>"discretionaryData"</para></entry><entry thead="no"><para>Discretionary data (if any) </para></entry></row><row><entry thead="no"><para>"firstName"</para></entry><entry thead="no"><para>Extracted cardholder's first name </para></entry></row><row><entry thead="no"><para>"lastName"</para></entry><entry thead="no"><para>Extracted cardholder's last name </para></entry></row></table></para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MsSetCardDataMode">
      <MemberSignature Language="C#" Value="public virtual bool MsSetCardDataMode (int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MsSetCardDataMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("msSetCardDataMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">magnetic card data mode: MS_PROCESSED_CARD_DATACard data will be processed and will be returned via call to magneticCardData MS_RAW_CARD_DATACard data will not be processed and will be returned via call to magneticCardRawData </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sets <see cref="T:LineaProSdk.Linea" />'s magnetic card data mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sets <see cref="T:LineaProSdk.Linea" />'s magnetic card data mode. This setting is not persistent and is best to configure it upon connect. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PlaySound">
      <MemberSignature Language="C#" Value="public bool PlaySound (int volume, int[] tones, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool PlaySound(int32 volume, int32[] tones, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="volume" Type="System.Int32" />
        <Parameter Name="tones" Type="System.Int32[]" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="volume">To be added.</param>
        <param name="tones">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveDelegate">
      <MemberSignature Language="C#" Value="public virtual void RemoveDelegate (MonoTouch.Foundation.NSObject newDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveDelegate(class MonoTouch.Foundation.NSObject newDelegate) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("removeDelegate:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newDelegate" Type="MonoTouch.Foundation.NSObject" />
      </Parameters>
      <Docs>
        <param name="newDelegate">the delegate that will be no longer be notified of  events </param>
        <summary>
          <para>Removes delegate, previously added with addDelegate </para>
        </summary>
        <remarks>
          <para>Removes delegate, previously added with addDelegate </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RfClose">
      <MemberSignature Language="C#" Value="public virtual bool RfClose (out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool RfClose(class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rfClose:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Powers down RF card reader module. Call this function after you are done with the reader. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Powers down RF card reader module. Call this function after you are done with the reader. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RfInit">
      <MemberSignature Language="C#" Value="public virtual bool RfInit (int supportedCards, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool RfInit(int32 supportedCards, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rfInit:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="supportedCards" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="supportedCards">any combination of CARD_SUPPORT_* flags to mark which card types to be active. Enable only cards you actually plan to work with, this has high implication on power usage and detection speed. </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Initializes and powers on the RF card reader module. Call this function before any other RF card functions. The module power consumption is highly optimized, so it can be left on for extended periods of time. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Initializes and powers on the RF card reader module. Call this function before any other RF card functions. The module power consumption is highly optimized, so it can be left on for extended periods of time. <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RfRemoveCard">
      <MemberSignature Language="C#" Value="public virtual bool RfRemoveCard (int cardIndex, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool RfRemoveCard(int32 cardIndex, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("rfRemoveCard:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cardIndex" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="cardIndex">the index of the card as sent by rfCardDetected delegate call </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Call this function once you are done with the card, a delegate call rfCardRemoved will be called when the card leaves the RF field and new card is ready to be detected <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Call this function once you are done with the card, a delegate call rfCardRemoved will be called when the card leaves the RF field and new card is ready to be detected <para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SdkVersion">
      <MemberSignature Language="C#" Value="public virtual int SdkVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SdkVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sdkVersion")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>SDK version number in format MAJOR*100+MINOR, i.e. version 1.15 will be returned as 115 </para>
        </summary>
        <value>To be added.</value>
        <remarks>
          <para>SDK version number in format MAJOR*100+MINOR, i.e. version 1.15 will be returned as 115 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerialNumber">
      <MemberSignature Language="C#" Value="public virtual string SerialNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SerialNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("serialNumber", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCharging">
      <MemberSignature Language="C#" Value="public virtual bool SetCharging (bool enabled, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetCharging(bool enabled, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setCharging:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enabled">TRUE to enable charging, FALSE to disable/stop it </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Enables or disables Lines's capability to charge the handheld from it's own battery. Charging can stop if <see cref="T:LineaProSdk.Linea" />'s battery goes too low.</para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Enables or disables Lines's capability to charge the handheld from it's own battery. Charging can stop if <see cref="T:LineaProSdk.Linea" />'s battery goes too low.</para>
          <para>
            <linebreak />
While <see cref="T:LineaProSdk.Linea" /> can act as external battery for the iPod/iPhone, there are certain limitations if you decide to implement it. The internal battery is not big enough, so if the iPod/iPhone consumes a lot of power from it, it will go down very fast and force the firmware to cut the charge to prevent going down to dangerous levels. The proper use of this charging function depends on how the program, running on the iPod/iPhone, is used and how the iPod/iPhone is discharged</para>
          <para>
            <linebreak />
There are two possible ways to use <see cref="T:LineaProSdk.Linea" />'s charge:<list type="bullet"><item><description>Emergency mode - in the case iPod/iPhone usage is designed in a way it will last long enough between charging sessions and using Linea's charge is not generally needed, the charge can be used if the iPod/iPhone for some reason goes too low (like &lt;50%), so it is given some power to continue working until next charging. An example will be store, where devices are being charged every night, but extreme usage on some iPod drains the battery before the end of the shift. This is the less efficient way to charge it, also, Linea will refuse to start the charge if it's own battery goes below 3.8v, so depending on the usage, barcode type and if the barcode engine is set to work all the time, it may not be possible to start the charge.</description></item><item><description>Max life mode - it is the case where both devices are required to operate as long as possible. Usually, the iPod/iPhone's battery will be drained way faster than Linea's, especially with wifi enabled programs and to keep both devices operating as long as possible, the charging should be desinged in a way so iPod/iPhone is able to use most of Linea's battery. This is possible, if you start charging when iPod/iPhone is almost full - at around 75-80% or higher. This way the iPod will consume small amount of energy, allowing our battery to slowly be used almost fully to charge it.</description></item></list></para>
          <para>
            <linebreak />
LineaDemo application contains sample implementation of max life mode charging.</para>
          <para>
            <para>Reading battery voltages during charging is unreliable! </para>
            <simplesectsep />
            <para>Enabling charge can fail if <see cref="T:LineaProSdk.Linea" />'s battery is low. Disabling charge will fail if there is external charger or usb cable attached.</para>
            <para>TRUE if function succeeded, FALSE otherwise </para>
          </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetScanBeep">
      <MemberSignature Language="C#" Value="public bool SetScanBeep (bool enabled, int volume, int[] tones, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SetScanBeep(bool enabled, int32 volume, int32[] tones, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enabled" Type="System.Boolean" />
        <Parameter Name="volume" Type="System.Int32" />
        <Parameter Name="tones" Type="System.Int32[]" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enabled">To be added.</param>
        <param name="volume">To be added.</param>
        <param name="tones">To be added.</param>
        <param name="error">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSyncButtonMode">
      <MemberSignature Language="C#" Value="public virtual bool SetSyncButtonMode (int mode, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetSyncButtonMode(int32 mode, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("setSyncButtonMode:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Int32" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="mode">button mode, one of the: BUTTON_DISABLED's will not perform synchronization when you press and hold the button for 3 seconds BUTTON_ENABLED (default)'s will perform synchronization when you press and hold the button for 3 seconds </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Sets <see cref="T:LineaProSdk.Linea" />'s sync button mode. This setting is stored into flash memory and will persist. <para>Although this function was made for <see cref="T:LineaProSdk.Linea" /> 1, that had hardware button to enter sync mode, it still works for enabling/disabling automated sync on <see cref="T:LineaProSdk.Linea" /> 4 and onward </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Sets <see cref="T:LineaProSdk.Linea" />'s sync button mode. This setting is stored into flash memory and will persist. <para>Although this function was made for <see cref="T:LineaProSdk.Linea" /> 1, that had hardware button to enter sync mode, it still works for enabling/disabling automated sync on <see cref="T:LineaProSdk.Linea" /> 4 and onward </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SharedDevice">
      <MemberSignature Language="C#" Value="public static LineaProSdk.Linea SharedDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class LineaProSdk.Linea SharedDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("sharedDevice")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>LineaProSdk.Linea</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <para>Creates and initializes new <see cref="T:LineaProSdk.Linea" /> class instance or returns already initalized one. Use this function, if you want to access the class from different places <para>shared class instance </para></para>
        </summary>
        <value>To be added.</value>
        <remarks>
          <para>Creates and initializes new <see cref="T:LineaProSdk.Linea" /> class instance or returns already initalized one. Use this function, if you want to access the class from different places <para>shared class instance </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateFirmwareData">
      <MemberSignature Language="C#" Value="public virtual bool UpdateFirmwareData (MonoTouch.Foundation.NSData data, out MonoTouch.Foundation.NSError error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool UpdateFirmwareData(class MonoTouch.Foundation.NSData data, class MonoTouch.Foundation.NSError error) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>MonoTouch.Foundation.Export("updateFirmwareData:error:")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="MonoTouch.Foundation.NSData" />
        <Parameter Name="error" Type="MonoTouch.Foundation.NSError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="data">the firmware data </param>
        <param name="error">pointer to NSError object, where error information is stored in case function fails. You can pass nil if you don't want that information </param>
        <summary>
          <para>Updates <see cref="T:LineaProSdk.Linea" />'s firmware with specified firmware data. The firmware can only be upgraded or downgraded, if you send the same firmware version, then no update process will be started. <para>Make sure the user does not interrupt the process or the device will be rendered unusable and can only be recovered via the special firmware update cable </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Updates <see cref="T:LineaProSdk.Linea" />'s firmware with specified firmware data. The firmware can only be upgraded or downgraded, if you send the same firmware version, then no update process will be started. <para>Make sure the user does not interrupt the process or the device will be rendered unusable and can only be recovered via the special firmware update cable </para><para>TRUE if function succeeded, FALSE otherwise </para></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WeakDelegate">
      <MemberSignature Language="C#" Value="public virtual MonoTouch.Foundation.NSObject WeakDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class MonoTouch.Foundation.NSObject WeakDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: MonoTouch.Foundation.Export("delegate", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: MonoTouch.Foundation.Export("setDelegate:", MonoTouch.ObjCRuntime.ArgumentSemantic.Assign)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>MonoTouch.Foundation.NSObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>